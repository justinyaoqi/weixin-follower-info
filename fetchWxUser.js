// Generated by CoffeeScript 1.10.0
(function() {
  var EventEmitter, FetchWxUser, STATUS, _, async, request,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  async = require('async');

  request = require('request');

  _ = require('underscore');

  EventEmitter = require('events').EventEmitter;

  STATUS = {
    FREE: 0,
    RUNNING: 1
  };


  /*
  拉取公众号下所有关注微信的用户信息
  events
  'task start', Error, startOpenId
  'task finish', Error, info
  'user list', Error, userList
  'user', Error, userInfo
   */

  FetchWxUser = (function(superClass) {
    extend(FetchWxUser, superClass);

    function FetchWxUser(opt1) {
      var base, base1, base2, base3, base4, base5;
      this.opt = opt1;
      if (this.opt == null) {
        this.opt = {};
      }
      if ((base = this.opt).token == null) {
        base.token = '';
      }
      if ((base1 = this.opt).tokenUrl == null) {
        base1.tokenUrl = '';
      }
      if ((base2 = this.opt).nextOpenid == null) {
        base2.nextOpenid = null;
      }
      if ((base3 = this.opt).concurrency == null) {
        base3.concurrency = 10;
      }
      this.opt.concurrency = Math.max(this.opt.concurrency, 1);
      this.opt.concurrency = Math.min(this.opt.concurrency, 50);
      if ((base4 = this.opt).retryTimes == null) {
        base4.retryTimes = 3;
      }
      if ((base5 = this.opt).retryInterval == null) {
        base5.retryInterval = 1000;
      }
      this.status = STATUS.FREE;
      this.fetchedPage = 0;
      this.fetchedUser = 0;
      this.mainQueue = {};
      this.init();
    }

    FetchWxUser.prototype.reset = function() {
      this.status = STATUS.FREE;
      this.fetchedPage = 0;
      return this.fetchedUser = 0;
    };

    FetchWxUser.prototype.init = function() {
      this.mainQueue = async.queue((function(_this) {
        return function(job, done) {
          _this.fetchedPage++;
          return _this.getUserList(job, function(err, data) {
            var openIds, ref;
            _this.emit('user list', err, data);
            if (data && data.next_openid) {
              _this.mainQueue.push({
                nextId: data.next_openid
              });
            }
            if (err) {
              return done(err, data);
            } else if (data && data.count !== 0 && ((ref = data.data) != null ? ref.openid : void 0) && _.isArray(data.data.openid)) {
              openIds = data.data.openid;
              return _this.getUsersInfo(openIds, function(errors, users) {
                return done(errors, users);
              });
            } else {
              return done();
            }
          });
        };
      })(this));
      return this.mainQueue.drain = (function(_this) {
        return function() {
          _this.emit('task finish', null, _this.stat());
          return _this.reset();
        };
      })(this);
    };

    FetchWxUser.prototype.start = function(openid) {
      if (this.status === STATUS.RUNNING) {
        this.emit('task start', new Error('task is running'));
        return;
      }
      if (openid) {
        this.mainQueue.push({
          nextId: openid
        });
        return this.emit('task start', null, openid);
      } else {
        this.mainQueue.push({
          nextId: this.opt.nextOpenid
        });
        return this.emit('task start', null, this.opt.nextOpenid);
      }
    };

    FetchWxUser.prototype.getUserList = function(job, done) {
      var url;
      url = this.genUserListUrl(job.nextId);
      return this.getJson(url, done);
    };

    FetchWxUser.prototype.getUsersInfo = function(openIds, done) {
      var i, len, openid, queue, results;
      queue = async.queue((function(_this) {
        return function(job, _done) {
          return _this.getJson(_this.genUserInfoUrl(job.openid), function(error, userInfo) {
            if (error) {
              return _done(error);
            } else {
              return _done(error, userInfo);
            }
          });
        };
      })(this), this.opt.concurrency);
      queue.drain = function() {
        return done(null);
      };
      results = [];
      for (i = 0, len = openIds.length; i < len; i++) {
        openid = openIds[i];
        results.push(queue.push({
          openid: openid
        }, (function(_this) {
          return function(err, userInfo) {
            _this.fetchedUser++;
            return _this.emit('user', err, userInfo);
          };
        })(this)));
      }
      return results;
    };

    FetchWxUser.prototype.stat = function() {
      return {
        status: this.status,
        fetchedPage: this.fetchedPage,
        fetchedUser: this.fetchedUser
      };
    };

    FetchWxUser.prototype.getToken = function(done) {
      var url;
      if (this.opt.tokenUrl) {
        url = this.opt.tokenUrl;
      } else if (this.opt.clientId && this.opt.clientSecret) {
        url = "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=" + this.opt.clientId + "&secret=" + this.opt.clientSecret;
      } else {
        return done(null, {
          access_token: this.opt.token
        });
      }
      return this.getJson(url, done);
    };

    FetchWxUser.prototype.genUserListUrl = function(openid) {
      var url;
      url = "https://api.weixin.qq.com/cgi-bin/user/get";
      if (openid) {
        url += "?next_openid=" + openid;
      }
      return url;
    };

    FetchWxUser.prototype.genUserInfoUrl = function(openid) {
      return "https://api.weixin.qq.com/cgi-bin/user/info?&openid=" + openid + "&lang=zh_CN";
    };

    FetchWxUser.prototype.getJson = function(url, done) {
      return async.retry({
        times: this.opt.retryTimes,
        interval: this.opt.retryInterval
      }, (function(_this) {
        return function(_done) {
          var opt;
          opt = {
            url: url,
            json: true,
            qs: {
              access_token: _this.opt.token
            },
            method: 'get'
          };
          return request(opt, function(error, resp, body) {
            if (error) {
              return _done(error);
            } else if (body && body.errcode !== void 0) {
              if (body.errcode === 41001) {
                return _this.getToken(function(error, data) {
                  if (!error) {
                    _this.opt.token = data.access_token;
                  }
                  return _done(new Error('invalid token'));
                });
              } else {
                return _done(new Error(body.errmsg));
              }
            } else {
              return _done(error, body);
            }
          });
        };
      })(this), done);
    };

    return FetchWxUser;

  })(EventEmitter);

  module.exports = FetchWxUser;

}).call(this);

//# sourceMappingURL=fetchWxUser.js.map
